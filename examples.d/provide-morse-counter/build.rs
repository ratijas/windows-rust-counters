use std::env;
use std::error::Error;
use std::path::PathBuf;

use regex::Regex;
use path_slash::PathBufExt;

const MODULE_DEFINITION: &'static str = "./resources/exports.def";
const SYMBOLS_H: &'static str = "./resources/symbols.h";

fn main() {
    cargo_emit::rerun_if_changed!(SYMBOLS_H);
    // Write the bindings to the $OUT_DIR/bindings.rs file.
    let in_path = PathBuf::from(SYMBOLS_H);
    let out_path = PathBuf::from(env::var("OUT_DIR").unwrap()).join("symbols.rs");
    bindgen_define(in_path, out_path)
        .expect("Couldn't write symbols!");

    let module_definition = PathBuf::from(env::current_dir().unwrap())
        .join(PathBuf::from_slash(MODULE_DEFINITION))
        .to_string_lossy()
        .into_owned();
    cargo_emit::rerun_if_changed!(module_definition);
    cargo_emit::rustc_cdylib_link_arg!(format!("/DEF:{}", module_definition))
}

// basic replacer
fn bindgen_define(src: PathBuf, dst: PathBuf) -> Result<(), Box<dyn Error>> {
    let input = std::fs::read_to_string(src)?;
    let mut rust = "/* Automatically generated by build script */\n\n".to_string();

    let define = Regex::new(r#"(?imx)^
        # define with spaces around
        (?:\s*)\x23(?:\s*)define(?:\s+)
        (?P<name>\w+)(?:\s+)
        (?P<value>.+)
    $"#).unwrap();

    input.lines()
        .filter_map(|line| {
            define.captures(line).map(|cap| {
                let name = cap.name("name").unwrap().as_str();
                let value = cap.name("value").unwrap().as_str();
                (name, value)
            })
        })
        .map(|(name, value)| {
            format!("pub const {}: u32 = {};\n", name, value)
        }).for_each(|line| rust.push_str(&line));
    std::fs::write(dst, &rust)?;

    Ok(())
}
